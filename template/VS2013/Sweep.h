#pragma once
#include <vector>
#include "glfw3.h"
#include "glm.hpp"


// Given a number of profile polyline vertices p and a number of trajectory polyline vertices t, computes the array of vertex indices to draw each triangle in the
// translational sweep.
std::vector<GLuint> computeSweepIndices(const int p, const int t);


// Given a std::vector of 3D vectors representing vertices of a polyline (curve), computes the displacement of each vertex from the first vertex.
std::vector<glm::vec3> computeDisplacements(const std::vector<glm::vec3>& polyline);


// Compute the translational sweep generated by two polylines in 3D. The profileCurve is translated by the trajectoryCurve.
std::vector<glm::vec3> computeTranslationalSweep(const std::vector<glm::vec3>& profilePolyline, const std::vector<glm::vec3>& trajectoryPolyline);


// Rotates a polyline once by a given angle
std::vector<glm::vec3> rotatePolyline(const std::vector<glm::vec3>& polyline, const GLfloat angle);


// Produces a rotational sweep from a  profile curve and number of spans
std::vector<glm::vec3> computeRotationalSweep(const std::vector<glm::vec3>& profilePolyline, const int numSpans);


// Interprets a vector of vec2 as a vector of vec3 in the x-y plane.
std::vector<glm::vec3> embed(const std::vector<glm::vec2>& vertices);


// Flattens an std::vector of n glm::vec3s into an std::vector of 3 * n GLfloats.
std::vector<GLfloat> flatten(const std::vector<glm::vec3> vertices);